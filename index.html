<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Canvas with Layers & Tools</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        height: 100%;
      }
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fff;
        touch-action: none;
        cursor: crosshair;
      }

      /* Save Button */
      #saveBtn {
        position: fixed;
        top: 20px;
        left: 20px;
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        cursor: pointer;
        opacity: 0.7;
        z-index: 110;
      }
      #saveBtn:hover {
        opacity: 1;
      }

      /* Panel base */
      .panel {
        background: #fafafa;
        border: 1px solid #ddd;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        padding: 10px;
        box-sizing: border-box;
        font-family: system-ui, -apple-system, sans-serif;
      }

      /* Tool Panel */
      #toolPanel {
        position: fixed;
        top: 60px;
        left: 20px;
        width: 100px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 100;
      }
      .toolBtn {
        width: 48px;
        height: 48px;
        margin: 0 auto;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: border-color 0.2s, background 0.2s;
      }
      .toolBtn:hover {
        border-color: #999;
      }
      .toolBtn.active {
        border-color: #007aff;
        background: #e6f4ff;
      }

      /* Popup for tool options */
      #toolPopup {
        position: absolute;
        display: none;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        z-index: 120;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .popup-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #toolPopup input[type="range"] {
        -webkit-appearance: none;
        width: 140px;
        height: 6px;
        background: #eee;
        border-radius: 3px;
        cursor: pointer;
      }
      #toolPopup input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: #333;
        border-radius: 50%;
        cursor: pointer;
        margin-top: -4px;
      }
      #toolPopup input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: #333;
        border: none;
        border-radius: 50%;
        cursor: pointer;
      }
      #toolPopup input[type="color"] {
        width: 80px;
        height: 32px;
        border: none;
        cursor: pointer;
      }
      #toolPopup input[type="number"] {
        width: 50px;
        font-size: 14px;
        text-align: center;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 4px;
        background: #f9f9f9;
      }

      /* Layer Panel */
      #layerPanel {
        position: fixed;
        top: 20px;
        right: 20px;
        bottom: 20px;
        width: 100px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto;
        z-index: 100;
      }
      #addLayerBtn {
        width: 60px;
        height: 30px;
        margin: 0 auto;
        border: 1px solid #aaa;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
        font-size: 20px;
        line-height: 30px;
        text-align: center;
      }
      #addLayerBtn:hover {
        border-color: #888;
      }
      ul#layersList {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .layerItem {
        position: relative;
        width: 60px;
        height: 60px;
        margin: 0 auto;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: border-color 0.2s;
      }
      .layerItem.active {
        border-color: #007aff;
      }
      .thumbnail {
        width: 52px;
        height: 52px;
        border-radius: 4px;
      }
      .visibilityBtn,
      .deleteBtn {
        position: absolute;
        width: 20px;
        height: 20px;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        border-radius: 4px;
      }
      .visibilityBtn {
        top: 4px;
        left: 4px;
      }
      .deleteBtn {
        bottom: 4px;
        left: 4px;
      }
    </style>
  </head>
  <body>
    <button id="saveBtn" title="Save"></button>
    <div id="toolPanel" class="panel">
      <button class="toolBtn pen active" data-tool="pen">‚úèÔ∏è</button>
      <button class="toolBtn eraser" data-tool="eraser">ü©π</button>
      <button class="toolBtn undo" data-tool="undo">‚Ü∂</button>
      <button class="toolBtn redo" data-tool="redo">‚Ü∑</button>
    </div>
    <div id="toolPopup" class="panel"></div>
    <div id="layerPanel" class="panel">
      <button id="addLayerBtn" title="Add Layer">+</button>
      <ul id="layersList"></ul>
    </div>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas"),
        ctx = canvas.getContext("2d");
      const toolPanel = document.getElementById("toolPanel"),
        toolPopup = document.getElementById("toolPopup");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawAll();
      });
      document.addEventListener("contextmenu", (e) => e.preventDefault());

      let isDrawing = false,
        isPanning = false;
      let lastPos = [0, 0],
        panStart = [0, 0];
      let offsetX = 0,
        offsetY = 0,
        zoom = 1;

      let layers = [],
        currentLayer = 0;
      let currentTool = "pen";
      let brushColor = "#000",
        brushSize = 4;
      let undoStack = [],
        redoStack = [];

      function saveState() {
        undoStack.push(JSON.parse(JSON.stringify(layers)));
        if (undoStack.length > 100) undoStack.shift();
        redoStack = [];
      }
      function undo() {
        if (undoStack.length) {
          redoStack.push(JSON.parse(JSON.stringify(layers)));
          layers = undoStack.pop();
          currentLayer = Math.min(currentLayer, layers.length - 1);
          renderLayersUI();
          drawAll();
        }
      }
      function redo() {
        if (redoStack.length) {
          undoStack.push(JSON.parse(JSON.stringify(layers)));
          layers = redoStack.pop();
          currentLayer = Math.min(currentLayer, layers.length - 1);
          renderLayersUI();
          drawAll();
        }
      }

      function updateToolUI() {
        document
          .querySelectorAll(".toolBtn")
          .forEach((btn) =>
            btn.classList.toggle("active", btn.dataset.tool === currentTool)
          );
      }

      function showToolPopup(btn) {
        const r = btn.getBoundingClientRect();
        toolPopup.innerHTML = "";
        if (currentTool === "pen") {
          const colorInp = document.createElement("input");
          colorInp.type = "color";
          colorInp.value = brushColor;
          colorInp.addEventListener(
            "input",
            (e) => (brushColor = e.target.value)
          );
          const row = document.createElement("div");
          row.className = "popup-row";
          const sizeInp = document.createElement("input");
          sizeInp.type = "range";
          sizeInp.min = 1;
          sizeInp.max = 50;
          sizeInp.value = brushSize;
          const numInp = document.createElement("input");
          numInp.type = "number";
          numInp.min = 1;
          numInp.max = 50;
          numInp.value = brushSize;
          sizeInp.addEventListener("input", (e) => {
            brushSize = +e.target.value;
            numInp.value = brushSize;
          });
          numInp.addEventListener("input", (e) => {
            brushSize = +e.target.value;
            sizeInp.value = brushSize;
          });
          row.append(sizeInp, numInp);
          toolPopup.append(colorInp, row);
        } else if (currentTool === "eraser") {
          const row = document.createElement("div");
          row.className = "popup-row";
          const sizeInp = document.createElement("input");
          sizeInp.type = "range";
          sizeInp.min = 5;
          sizeInp.max = 100;
          sizeInp.value = brushSize;
          const numInp = document.createElement("input");
          numInp.type = "number";
          numInp.min = 5;
          numInp.max = 100;
          numInp.value = brushSize;
          sizeInp.addEventListener("input", (e) => {
            brushSize = +e.target.value;
            numInp.value = brushSize;
          });
          numInp.addEventListener("input", (e) => {
            brushSize = +e.target.value;
            sizeInp.value = brushSize;
          });
          row.append(sizeInp, numInp);
          toolPopup.append(row);
        }
        toolPopup.style.left = r.right + 10 + "px";
        toolPopup.style.top = r.top + "px";
        toolPopup.style.display = "flex";
      }

      document.getElementById("saveBtn").addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "canvas.png";
        link.href = canvas.toDataURL();
        link.click();
      });
      document.querySelectorAll(".toolBtn").forEach((btn) =>
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const t = btn.dataset.tool;
          if (t === "undo") undo();
          else if (t === "redo") redo();
          else {
            currentTool = t;
            updateToolUI();
            showToolPopup(btn);
          }
        })
      );
      document.addEventListener("click", (e) => {
        if (!toolPanel.contains(e.target) && !toolPopup.contains(e.target))
          toolPopup.style.display = "none";
      });

      document.getElementById("addLayerBtn").addEventListener("click", () => {
        saveState();
        createLayer();
      });
      function createLayer() {
        layers.push({ strokes: [] });
        currentLayer = layers.length - 1;
        renderLayersUI();
        drawAll();
      }
      function renderLayersUI() {
        const list = document.getElementById("layersList");
        list.innerHTML = "";
        layers.forEach((layer, i) => {
          const li = document.createElement("li");
          li.className = "layerItem" + (i === currentLayer ? " active" : "");
          li.dataset.index = i;
          const thumb = document.createElement("canvas");
          thumb.width = 52;
          thumb.height = 52;
          thumb.className = "thumbnail";
          const tctx = thumb.getContext("2d");
          tctx.clearRect(0, 0, 52, 52);
          // render thumbnail
          let bounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity,
          };
          layer.strokes.forEach((st) =>
            st.points.forEach((p) => {
              bounds.minX = Math.min(bounds.minX, p[0]);
              bounds.minY = Math.min(bounds.minY, p[1]);
              bounds.maxX = Math.max(bounds.maxX, p[0]);
              bounds.maxY = Math.max(bounds.maxY, p[1]);
            })
          );
          const w = bounds.maxX - bounds.minX || 1,
            h = bounds.maxY - bounds.minY || 1,
            s = Math.min(52 / w, 52 / h);
          layer.strokes.forEach((st) => {
            tctx.beginPath();
            st.points.forEach((p, j) => {
              const x = (p[0] - bounds.minX) * s,
                y = (p[1] - bounds.minY) * s;
              j ? tctx.lineTo(x, y) : tctx.moveTo(x, y);
            });
            tctx.stroke();
          });
          li.appendChild(thumb);
          // visibility & delete
          const vis = document.createElement("button");
          vis.className = "visibilityBtn";
          vis.textContent = "üëÅ";
          vis.style.opacity = 1;
          vis.addEventListener("click", (e) => {
            e.stopPropagation();
            saveState();
            layer.visible = !layer.visible;
            renderLayersUI();
            drawAll();
          });
          li.appendChild(vis);
          if (i === currentLayer) {
            const del = document.createElement("button");
            del.className = "deleteBtn";
            del.textContent = "üóë";
            del.addEventListener("click", (e) => {
              e.stopPropagation();
              saveState();
              layers.splice(i, 1);
              currentLayer = Math.max(0, currentLayer - 1);
              renderLayersUI();
              drawAll();
            });
            li.appendChild(del);
          }
          li.addEventListener("click", () => {
            currentLayer = i;
            renderLayersUI();
          });
          list.appendChild(li);
        });
      }

      function drawAll() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(zoom, 0, 0, zoom, offsetX, offsetY);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        layers.forEach((layer) => {
          if (!layer.visible) return;
          layer.strokes.forEach((st) => {
            ctx.globalCompositeOperation = st.composite;
            ctx.strokeStyle = st.color;
            ctx.lineWidth = st.size;
            ctx.beginPath();
            st.points.forEach((p, j) =>
              j ? ctx.lineTo(p[0], p[1]) : ctx.moveTo(p[0], p[1])
            );
            ctx.stroke();
          });
        });
        ctx.globalCompositeOperation = "source-over";
      }

      let currentStroke = null;
      canvas.addEventListener("pointerdown", (e) => {
        if (e.button === 2) {
          isPanning = true;
          panStart = [e.clientX, e.clientY];
          return;
        }
        if (!["pen", "eraser"].includes(currentTool)) return;
        isDrawing = true;
        saveState();
        const [x, y] = [
          (e.clientX - offsetX) / zoom,
          (e.clientY - offsetY) / zoom,
        ];
        currentStroke = {
          points: [[x, y]],
          color: currentTool === "pen" ? brushColor : "#fff",
          size: brushSize,
          composite:
            currentTool === "eraser" ? "destination-out" : "source-over",
        };
        layers[currentLayer].strokes.push(currentStroke);
        lastPos = [x, y];
      });
      canvas.addEventListener("pointermove", (e) => {
        if (isDrawing) {
          const [x, y] = [
            (e.clientX - offsetX) / zoom,
            (e.clientY - offsetY) / zoom,
          ];
          ctx.setTransform(zoom, 0, 0, zoom, offsetX, offsetY);
          ctx.globalCompositeOperation = currentStroke.composite;
          ctx.strokeStyle = currentStroke.color;
          ctx.lineWidth = currentStroke.size;
          ctx.beginPath();
          ctx.moveTo(lastPos[0], lastPos[1]);
          ctx.lineTo(x, y);
          ctx.stroke();
          currentStroke.points.push([x, y]);
          lastPos = [x, y];
        } else if (isPanning) {
          offsetX += e.clientX - panStart[0];
          offsetY += e.clientY - panStart[1];
          panStart = [e.clientX, e.clientY];
          drawAll();
        }
      });
      canvas.addEventListener("pointerup", (e) => {
        if (e.button === 2) isPanning = false;
        else if (isDrawing) {
          isDrawing = false;
          currentStroke = null;
          renderLayersUI();
        }
      });
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const s = e.deltaY < 0 ? 1.1 : 0.9;
          const mx = e.clientX,
            my = e.clientY;
          const cx = (mx - offsetX) / zoom,
            cy = (my - offsetY) / zoom;
          zoom *= s;
          offsetX = mx - cx * zoom;
          offsetY = my - cy * zoom;
          drawAll();
        },
        { passive: false }
      );

      createLayer();
      updateToolUI();
    </script>
  </body>
</html>
